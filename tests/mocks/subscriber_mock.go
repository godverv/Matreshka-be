package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// SubscriberMock implements service.Subscriber
type SubscriberMock struct {
	t minimock.Tester

	funcCancel          func()
	inspectFuncCancel   func()
	afterCancelCounter  uint64
	beforeCancelCounter uint64
	CancelMock          mSubscriberMockCancel

	funcSubscribe          func(serviceNames ...string)
	inspectFuncSubscribe   func(serviceNames ...string)
	afterSubscribeCounter  uint64
	beforeSubscribeCounter uint64
	SubscribeMock          mSubscriberMockSubscribe

	funcUnsubscribe          func(serviceNames ...string)
	inspectFuncUnsubscribe   func(serviceNames ...string)
	afterUnsubscribeCounter  uint64
	beforeUnsubscribeCounter uint64
	UnsubscribeMock          mSubscriberMockUnsubscribe

	funcUpdatesChan          func() (ch1 chan any)
	inspectFuncUpdatesChan   func()
	afterUpdatesChanCounter  uint64
	beforeUpdatesChanCounter uint64
	UpdatesChanMock          mSubscriberMockUpdatesChan
}

// NewSubscriberMock returns a mock for service.Subscriber
func NewSubscriberMock(t minimock.Tester) *SubscriberMock {
	m := &SubscriberMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelMock = mSubscriberMockCancel{mock: m}

	m.SubscribeMock = mSubscriberMockSubscribe{mock: m}
	m.SubscribeMock.callArgs = []*SubscriberMockSubscribeParams{}

	m.UnsubscribeMock = mSubscriberMockUnsubscribe{mock: m}
	m.UnsubscribeMock.callArgs = []*SubscriberMockUnsubscribeParams{}

	m.UpdatesChanMock = mSubscriberMockUpdatesChan{mock: m}

	return m
}

type mSubscriberMockCancel struct {
	mock               *SubscriberMock
	defaultExpectation *SubscriberMockCancelExpectation
	expectations       []*SubscriberMockCancelExpectation
}

// SubscriberMockCancelExpectation specifies expectation struct of the Subscriber.Cancel
type SubscriberMockCancelExpectation struct {
	mock *SubscriberMock

	Counter uint64
}

// Expect sets up expected params for Subscriber.Cancel
func (mmCancel *mSubscriberMockCancel) Expect() *mSubscriberMockCancel {
	if mmCancel.mock.funcCancel != nil {
		mmCancel.mock.t.Fatalf("SubscriberMock.Cancel mock is already set by Set")
	}

	if mmCancel.defaultExpectation == nil {
		mmCancel.defaultExpectation = &SubscriberMockCancelExpectation{}
	}

	return mmCancel
}

// Inspect accepts an inspector function that has same arguments as the Subscriber.Cancel
func (mmCancel *mSubscriberMockCancel) Inspect(f func()) *mSubscriberMockCancel {
	if mmCancel.mock.inspectFuncCancel != nil {
		mmCancel.mock.t.Fatalf("Inspect function is already set for SubscriberMock.Cancel")
	}

	mmCancel.mock.inspectFuncCancel = f

	return mmCancel
}

// Return sets up results that will be returned by Subscriber.Cancel
func (mmCancel *mSubscriberMockCancel) Return() *SubscriberMock {
	if mmCancel.mock.funcCancel != nil {
		mmCancel.mock.t.Fatalf("SubscriberMock.Cancel mock is already set by Set")
	}

	if mmCancel.defaultExpectation == nil {
		mmCancel.defaultExpectation = &SubscriberMockCancelExpectation{mock: mmCancel.mock}
	}

	return mmCancel.mock
}

// Set uses given function f to mock the Subscriber.Cancel method
func (mmCancel *mSubscriberMockCancel) Set(f func()) *SubscriberMock {
	if mmCancel.defaultExpectation != nil {
		mmCancel.mock.t.Fatalf("Default expectation is already set for the Subscriber.Cancel method")
	}

	if len(mmCancel.expectations) > 0 {
		mmCancel.mock.t.Fatalf("Some expectations are already set for the Subscriber.Cancel method")
	}

	mmCancel.mock.funcCancel = f
	return mmCancel.mock
}

// Cancel implements service.Subscriber
func (mmCancel *SubscriberMock) Cancel() {
	mm_atomic.AddUint64(&mmCancel.beforeCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmCancel.afterCancelCounter, 1)

	if mmCancel.inspectFuncCancel != nil {
		mmCancel.inspectFuncCancel()
	}

	if mmCancel.CancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancel.CancelMock.defaultExpectation.Counter, 1)

		return

	}
	if mmCancel.funcCancel != nil {
		mmCancel.funcCancel()
		return
	}
	mmCancel.t.Fatalf("Unexpected call to SubscriberMock.Cancel.")

}

// CancelAfterCounter returns a count of finished SubscriberMock.Cancel invocations
func (mmCancel *SubscriberMock) CancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancel.afterCancelCounter)
}

// CancelBeforeCounter returns a count of SubscriberMock.Cancel invocations
func (mmCancel *SubscriberMock) CancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancel.beforeCancelCounter)
}

// MinimockCancelDone returns true if the count of the Cancel invocations corresponds
// the number of defined expectations
func (m *SubscriberMock) MinimockCancelDone() bool {
	for _, e := range m.CancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancel != nil && mm_atomic.LoadUint64(&m.afterCancelCounter) < 1 {
		return false
	}
	return true
}

// MinimockCancelInspect logs each unmet expectation
func (m *SubscriberMock) MinimockCancelInspect() {
	for _, e := range m.CancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SubscriberMock.Cancel")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelCounter) < 1 {
		m.t.Error("Expected call to SubscriberMock.Cancel")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancel != nil && mm_atomic.LoadUint64(&m.afterCancelCounter) < 1 {
		m.t.Error("Expected call to SubscriberMock.Cancel")
	}
}

type mSubscriberMockSubscribe struct {
	mock               *SubscriberMock
	defaultExpectation *SubscriberMockSubscribeExpectation
	expectations       []*SubscriberMockSubscribeExpectation

	callArgs []*SubscriberMockSubscribeParams
	mutex    sync.RWMutex
}

// SubscriberMockSubscribeExpectation specifies expectation struct of the Subscriber.Subscribe
type SubscriberMockSubscribeExpectation struct {
	mock   *SubscriberMock
	params *SubscriberMockSubscribeParams

	Counter uint64
}

// SubscriberMockSubscribeParams contains parameters of the Subscriber.Subscribe
type SubscriberMockSubscribeParams struct {
	serviceNames []string
}

// Expect sets up expected params for Subscriber.Subscribe
func (mmSubscribe *mSubscriberMockSubscribe) Expect(serviceNames ...string) *mSubscriberMockSubscribe {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("SubscriberMock.Subscribe mock is already set by Set")
	}

	if mmSubscribe.defaultExpectation == nil {
		mmSubscribe.defaultExpectation = &SubscriberMockSubscribeExpectation{}
	}

	mmSubscribe.defaultExpectation.params = &SubscriberMockSubscribeParams{serviceNames}
	for _, e := range mmSubscribe.expectations {
		if minimock.Equal(e.params, mmSubscribe.defaultExpectation.params) {
			mmSubscribe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSubscribe.defaultExpectation.params)
		}
	}

	return mmSubscribe
}

// Inspect accepts an inspector function that has same arguments as the Subscriber.Subscribe
func (mmSubscribe *mSubscriberMockSubscribe) Inspect(f func(serviceNames ...string)) *mSubscriberMockSubscribe {
	if mmSubscribe.mock.inspectFuncSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("Inspect function is already set for SubscriberMock.Subscribe")
	}

	mmSubscribe.mock.inspectFuncSubscribe = f

	return mmSubscribe
}

// Return sets up results that will be returned by Subscriber.Subscribe
func (mmSubscribe *mSubscriberMockSubscribe) Return() *SubscriberMock {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("SubscriberMock.Subscribe mock is already set by Set")
	}

	if mmSubscribe.defaultExpectation == nil {
		mmSubscribe.defaultExpectation = &SubscriberMockSubscribeExpectation{mock: mmSubscribe.mock}
	}

	return mmSubscribe.mock
}

// Set uses given function f to mock the Subscriber.Subscribe method
func (mmSubscribe *mSubscriberMockSubscribe) Set(f func(serviceNames ...string)) *SubscriberMock {
	if mmSubscribe.defaultExpectation != nil {
		mmSubscribe.mock.t.Fatalf("Default expectation is already set for the Subscriber.Subscribe method")
	}

	if len(mmSubscribe.expectations) > 0 {
		mmSubscribe.mock.t.Fatalf("Some expectations are already set for the Subscriber.Subscribe method")
	}

	mmSubscribe.mock.funcSubscribe = f
	return mmSubscribe.mock
}

// Subscribe implements service.Subscriber
func (mmSubscribe *SubscriberMock) Subscribe(serviceNames ...string) {
	mm_atomic.AddUint64(&mmSubscribe.beforeSubscribeCounter, 1)
	defer mm_atomic.AddUint64(&mmSubscribe.afterSubscribeCounter, 1)

	if mmSubscribe.inspectFuncSubscribe != nil {
		mmSubscribe.inspectFuncSubscribe(serviceNames...)
	}

	mm_params := &SubscriberMockSubscribeParams{serviceNames}

	// Record call args
	mmSubscribe.SubscribeMock.mutex.Lock()
	mmSubscribe.SubscribeMock.callArgs = append(mmSubscribe.SubscribeMock.callArgs, mm_params)
	mmSubscribe.SubscribeMock.mutex.Unlock()

	for _, e := range mmSubscribe.SubscribeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSubscribe.SubscribeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSubscribe.SubscribeMock.defaultExpectation.Counter, 1)
		mm_want := mmSubscribe.SubscribeMock.defaultExpectation.params
		mm_got := SubscriberMockSubscribeParams{serviceNames}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSubscribe.t.Errorf("SubscriberMock.Subscribe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSubscribe.funcSubscribe != nil {
		mmSubscribe.funcSubscribe(serviceNames...)
		return
	}
	mmSubscribe.t.Fatalf("Unexpected call to SubscriberMock.Subscribe. %v", serviceNames)

}

// SubscribeAfterCounter returns a count of finished SubscriberMock.Subscribe invocations
func (mmSubscribe *SubscriberMock) SubscribeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribe.afterSubscribeCounter)
}

// SubscribeBeforeCounter returns a count of SubscriberMock.Subscribe invocations
func (mmSubscribe *SubscriberMock) SubscribeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribe.beforeSubscribeCounter)
}

// Calls returns a list of arguments used in each call to SubscriberMock.Subscribe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSubscribe *mSubscriberMockSubscribe) Calls() []*SubscriberMockSubscribeParams {
	mmSubscribe.mutex.RLock()

	argCopy := make([]*SubscriberMockSubscribeParams, len(mmSubscribe.callArgs))
	copy(argCopy, mmSubscribe.callArgs)

	mmSubscribe.mutex.RUnlock()

	return argCopy
}

// MinimockSubscribeDone returns true if the count of the Subscribe invocations corresponds
// the number of defined expectations
func (m *SubscriberMock) MinimockSubscribeDone() bool {
	for _, e := range m.SubscribeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribe != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		return false
	}
	return true
}

// MinimockSubscribeInspect logs each unmet expectation
func (m *SubscriberMock) MinimockSubscribeInspect() {
	for _, e := range m.SubscribeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscriberMock.Subscribe with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		if m.SubscribeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscriberMock.Subscribe")
		} else {
			m.t.Errorf("Expected call to SubscriberMock.Subscribe with params: %#v", *m.SubscribeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribe != nil && mm_atomic.LoadUint64(&m.afterSubscribeCounter) < 1 {
		m.t.Error("Expected call to SubscriberMock.Subscribe")
	}
}

type mSubscriberMockUnsubscribe struct {
	mock               *SubscriberMock
	defaultExpectation *SubscriberMockUnsubscribeExpectation
	expectations       []*SubscriberMockUnsubscribeExpectation

	callArgs []*SubscriberMockUnsubscribeParams
	mutex    sync.RWMutex
}

// SubscriberMockUnsubscribeExpectation specifies expectation struct of the Subscriber.Unsubscribe
type SubscriberMockUnsubscribeExpectation struct {
	mock   *SubscriberMock
	params *SubscriberMockUnsubscribeParams

	Counter uint64
}

// SubscriberMockUnsubscribeParams contains parameters of the Subscriber.Unsubscribe
type SubscriberMockUnsubscribeParams struct {
	serviceNames []string
}

// Expect sets up expected params for Subscriber.Unsubscribe
func (mmUnsubscribe *mSubscriberMockUnsubscribe) Expect(serviceNames ...string) *mSubscriberMockUnsubscribe {
	if mmUnsubscribe.mock.funcUnsubscribe != nil {
		mmUnsubscribe.mock.t.Fatalf("SubscriberMock.Unsubscribe mock is already set by Set")
	}

	if mmUnsubscribe.defaultExpectation == nil {
		mmUnsubscribe.defaultExpectation = &SubscriberMockUnsubscribeExpectation{}
	}

	mmUnsubscribe.defaultExpectation.params = &SubscriberMockUnsubscribeParams{serviceNames}
	for _, e := range mmUnsubscribe.expectations {
		if minimock.Equal(e.params, mmUnsubscribe.defaultExpectation.params) {
			mmUnsubscribe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnsubscribe.defaultExpectation.params)
		}
	}

	return mmUnsubscribe
}

// Inspect accepts an inspector function that has same arguments as the Subscriber.Unsubscribe
func (mmUnsubscribe *mSubscriberMockUnsubscribe) Inspect(f func(serviceNames ...string)) *mSubscriberMockUnsubscribe {
	if mmUnsubscribe.mock.inspectFuncUnsubscribe != nil {
		mmUnsubscribe.mock.t.Fatalf("Inspect function is already set for SubscriberMock.Unsubscribe")
	}

	mmUnsubscribe.mock.inspectFuncUnsubscribe = f

	return mmUnsubscribe
}

// Return sets up results that will be returned by Subscriber.Unsubscribe
func (mmUnsubscribe *mSubscriberMockUnsubscribe) Return() *SubscriberMock {
	if mmUnsubscribe.mock.funcUnsubscribe != nil {
		mmUnsubscribe.mock.t.Fatalf("SubscriberMock.Unsubscribe mock is already set by Set")
	}

	if mmUnsubscribe.defaultExpectation == nil {
		mmUnsubscribe.defaultExpectation = &SubscriberMockUnsubscribeExpectation{mock: mmUnsubscribe.mock}
	}

	return mmUnsubscribe.mock
}

// Set uses given function f to mock the Subscriber.Unsubscribe method
func (mmUnsubscribe *mSubscriberMockUnsubscribe) Set(f func(serviceNames ...string)) *SubscriberMock {
	if mmUnsubscribe.defaultExpectation != nil {
		mmUnsubscribe.mock.t.Fatalf("Default expectation is already set for the Subscriber.Unsubscribe method")
	}

	if len(mmUnsubscribe.expectations) > 0 {
		mmUnsubscribe.mock.t.Fatalf("Some expectations are already set for the Subscriber.Unsubscribe method")
	}

	mmUnsubscribe.mock.funcUnsubscribe = f
	return mmUnsubscribe.mock
}

// Unsubscribe implements service.Subscriber
func (mmUnsubscribe *SubscriberMock) Unsubscribe(serviceNames ...string) {
	mm_atomic.AddUint64(&mmUnsubscribe.beforeUnsubscribeCounter, 1)
	defer mm_atomic.AddUint64(&mmUnsubscribe.afterUnsubscribeCounter, 1)

	if mmUnsubscribe.inspectFuncUnsubscribe != nil {
		mmUnsubscribe.inspectFuncUnsubscribe(serviceNames...)
	}

	mm_params := &SubscriberMockUnsubscribeParams{serviceNames}

	// Record call args
	mmUnsubscribe.UnsubscribeMock.mutex.Lock()
	mmUnsubscribe.UnsubscribeMock.callArgs = append(mmUnsubscribe.UnsubscribeMock.callArgs, mm_params)
	mmUnsubscribe.UnsubscribeMock.mutex.Unlock()

	for _, e := range mmUnsubscribe.UnsubscribeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmUnsubscribe.UnsubscribeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnsubscribe.UnsubscribeMock.defaultExpectation.Counter, 1)
		mm_want := mmUnsubscribe.UnsubscribeMock.defaultExpectation.params
		mm_got := SubscriberMockUnsubscribeParams{serviceNames}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnsubscribe.t.Errorf("SubscriberMock.Unsubscribe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmUnsubscribe.funcUnsubscribe != nil {
		mmUnsubscribe.funcUnsubscribe(serviceNames...)
		return
	}
	mmUnsubscribe.t.Fatalf("Unexpected call to SubscriberMock.Unsubscribe. %v", serviceNames)

}

// UnsubscribeAfterCounter returns a count of finished SubscriberMock.Unsubscribe invocations
func (mmUnsubscribe *SubscriberMock) UnsubscribeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnsubscribe.afterUnsubscribeCounter)
}

// UnsubscribeBeforeCounter returns a count of SubscriberMock.Unsubscribe invocations
func (mmUnsubscribe *SubscriberMock) UnsubscribeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnsubscribe.beforeUnsubscribeCounter)
}

// Calls returns a list of arguments used in each call to SubscriberMock.Unsubscribe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnsubscribe *mSubscriberMockUnsubscribe) Calls() []*SubscriberMockUnsubscribeParams {
	mmUnsubscribe.mutex.RLock()

	argCopy := make([]*SubscriberMockUnsubscribeParams, len(mmUnsubscribe.callArgs))
	copy(argCopy, mmUnsubscribe.callArgs)

	mmUnsubscribe.mutex.RUnlock()

	return argCopy
}

// MinimockUnsubscribeDone returns true if the count of the Unsubscribe invocations corresponds
// the number of defined expectations
func (m *SubscriberMock) MinimockUnsubscribeDone() bool {
	for _, e := range m.UnsubscribeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnsubscribeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnsubscribeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnsubscribe != nil && mm_atomic.LoadUint64(&m.afterUnsubscribeCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnsubscribeInspect logs each unmet expectation
func (m *SubscriberMock) MinimockUnsubscribeInspect() {
	for _, e := range m.UnsubscribeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscriberMock.Unsubscribe with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnsubscribeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnsubscribeCounter) < 1 {
		if m.UnsubscribeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscriberMock.Unsubscribe")
		} else {
			m.t.Errorf("Expected call to SubscriberMock.Unsubscribe with params: %#v", *m.UnsubscribeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnsubscribe != nil && mm_atomic.LoadUint64(&m.afterUnsubscribeCounter) < 1 {
		m.t.Error("Expected call to SubscriberMock.Unsubscribe")
	}
}

type mSubscriberMockUpdatesChan struct {
	mock               *SubscriberMock
	defaultExpectation *SubscriberMockUpdatesChanExpectation
	expectations       []*SubscriberMockUpdatesChanExpectation
}

// SubscriberMockUpdatesChanExpectation specifies expectation struct of the Subscriber.UpdatesChan
type SubscriberMockUpdatesChanExpectation struct {
	mock *SubscriberMock

	results *SubscriberMockUpdatesChanResults
	Counter uint64
}

// SubscriberMockUpdatesChanResults contains results of the Subscriber.UpdatesChan
type SubscriberMockUpdatesChanResults struct {
	ch1 chan any
}

// Expect sets up expected params for Subscriber.UpdatesChan
func (mmUpdatesChan *mSubscriberMockUpdatesChan) Expect() *mSubscriberMockUpdatesChan {
	if mmUpdatesChan.mock.funcUpdatesChan != nil {
		mmUpdatesChan.mock.t.Fatalf("SubscriberMock.UpdatesChan mock is already set by Set")
	}

	if mmUpdatesChan.defaultExpectation == nil {
		mmUpdatesChan.defaultExpectation = &SubscriberMockUpdatesChanExpectation{}
	}

	return mmUpdatesChan
}

// Inspect accepts an inspector function that has same arguments as the Subscriber.UpdatesChan
func (mmUpdatesChan *mSubscriberMockUpdatesChan) Inspect(f func()) *mSubscriberMockUpdatesChan {
	if mmUpdatesChan.mock.inspectFuncUpdatesChan != nil {
		mmUpdatesChan.mock.t.Fatalf("Inspect function is already set for SubscriberMock.UpdatesChan")
	}

	mmUpdatesChan.mock.inspectFuncUpdatesChan = f

	return mmUpdatesChan
}

// Return sets up results that will be returned by Subscriber.UpdatesChan
func (mmUpdatesChan *mSubscriberMockUpdatesChan) Return(ch1 chan any) *SubscriberMock {
	if mmUpdatesChan.mock.funcUpdatesChan != nil {
		mmUpdatesChan.mock.t.Fatalf("SubscriberMock.UpdatesChan mock is already set by Set")
	}

	if mmUpdatesChan.defaultExpectation == nil {
		mmUpdatesChan.defaultExpectation = &SubscriberMockUpdatesChanExpectation{mock: mmUpdatesChan.mock}
	}
	mmUpdatesChan.defaultExpectation.results = &SubscriberMockUpdatesChanResults{ch1}
	return mmUpdatesChan.mock
}

// Set uses given function f to mock the Subscriber.UpdatesChan method
func (mmUpdatesChan *mSubscriberMockUpdatesChan) Set(f func() (ch1 chan any)) *SubscriberMock {
	if mmUpdatesChan.defaultExpectation != nil {
		mmUpdatesChan.mock.t.Fatalf("Default expectation is already set for the Subscriber.UpdatesChan method")
	}

	if len(mmUpdatesChan.expectations) > 0 {
		mmUpdatesChan.mock.t.Fatalf("Some expectations are already set for the Subscriber.UpdatesChan method")
	}

	mmUpdatesChan.mock.funcUpdatesChan = f
	return mmUpdatesChan.mock
}

// UpdatesChan implements service.Subscriber
func (mmUpdatesChan *SubscriberMock) UpdatesChan() (ch1 chan any) {
	mm_atomic.AddUint64(&mmUpdatesChan.beforeUpdatesChanCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatesChan.afterUpdatesChanCounter, 1)

	if mmUpdatesChan.inspectFuncUpdatesChan != nil {
		mmUpdatesChan.inspectFuncUpdatesChan()
	}

	if mmUpdatesChan.UpdatesChanMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatesChan.UpdatesChanMock.defaultExpectation.Counter, 1)

		mm_results := mmUpdatesChan.UpdatesChanMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatesChan.t.Fatal("No results are set for the SubscriberMock.UpdatesChan")
		}
		return (*mm_results).ch1
	}
	if mmUpdatesChan.funcUpdatesChan != nil {
		return mmUpdatesChan.funcUpdatesChan()
	}
	mmUpdatesChan.t.Fatalf("Unexpected call to SubscriberMock.UpdatesChan.")
	return
}

// UpdatesChanAfterCounter returns a count of finished SubscriberMock.UpdatesChan invocations
func (mmUpdatesChan *SubscriberMock) UpdatesChanAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatesChan.afterUpdatesChanCounter)
}

// UpdatesChanBeforeCounter returns a count of SubscriberMock.UpdatesChan invocations
func (mmUpdatesChan *SubscriberMock) UpdatesChanBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatesChan.beforeUpdatesChanCounter)
}

// MinimockUpdatesChanDone returns true if the count of the UpdatesChan invocations corresponds
// the number of defined expectations
func (m *SubscriberMock) MinimockUpdatesChanDone() bool {
	for _, e := range m.UpdatesChanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatesChanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdatesChanCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatesChan != nil && mm_atomic.LoadUint64(&m.afterUpdatesChanCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdatesChanInspect logs each unmet expectation
func (m *SubscriberMock) MinimockUpdatesChanInspect() {
	for _, e := range m.UpdatesChanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SubscriberMock.UpdatesChan")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatesChanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdatesChanCounter) < 1 {
		m.t.Error("Expected call to SubscriberMock.UpdatesChan")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatesChan != nil && mm_atomic.LoadUint64(&m.afterUpdatesChanCounter) < 1 {
		m.t.Error("Expected call to SubscriberMock.UpdatesChan")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SubscriberMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCancelInspect()

		m.MinimockSubscribeInspect()

		m.MinimockUnsubscribeInspect()

		m.MinimockUpdatesChanInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SubscriberMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SubscriberMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelDone() &&
		m.MinimockSubscribeDone() &&
		m.MinimockUnsubscribeDone() &&
		m.MinimockUpdatesChanDone()
}
